<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>imagebuilder1837</title>
  
  <subtitle>imagebuilder1837&#39;s blog</subtitle>
  <link href="https://imagebuilder1837.github.io/atom.xml" rel="self"/>
  
  <link href="https://imagebuilder1837.github.io/"/>
  <updated>2025-11-04T13:04:45.386Z</updated>
  <id>https://imagebuilder1837.github.io/</id>
  
  <author>
    <name>imagebuilder1837</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>有关高中的大致理想</title>
    <link href="https://imagebuilder1837.github.io/2025/11/04/2025-11-04-2/"/>
    <id>https://imagebuilder1837.github.io/2025/11/04/2025-11-04-2/</id>
    <published>2025-11-04T12:29:14.000Z</published>
    <updated>2025-11-04T13:04:45.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有关高中的大致理想"><a href="#有关高中的大致理想" class="headerlink" title="有关高中的大致理想"></a>有关高中的大致理想</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>高考制度本身存在结构性问题。现在的高考纯粹是作为一个教育信号而不是能力的体现，<a href="#%E5%8F%82%E8%80%83">¹</a>这才是导致零和博弈的根本原因</p><h2 id="中学阶段"><a href="#中学阶段" class="headerlink" title="中学阶段"></a>中学阶段</h2><p>我理想中整个初高中的中学阶段应该作为小学通识教育向大学专业深造的过渡而存在，目的是让学生了解世界上专业的多样性，对它们有个初步的认知并借此发现自己的兴趣特长，而不是像现在一样在十门甚至九门狭小的科目里卷来卷去。因此，高考在我的理想中也是不必要的。如果能把学生掌握的知识与数年的成长路线本身作为呈现，<a href="#%E5%8F%82%E8%80%83">²</a>又何必采取一考定终生这样草菅人命的做法？</p><h2 id="作为评价标准的考核"><a href="#作为评价标准的考核" class="headerlink" title="作为评价标准的考核"></a>作为评价标准的考核</h2><p>我对“作为评价标准的考核”本身就持负面态度，考核这种形式决定了其只能测试某一个时间点的学生，将其作为评价标准必然会引导学生走上平时懈怠、考前冲刺、考后放纵这种对考核的过拟合的道路。就算真的得使用考核这种形式，用分数来呈现其结果也是糟糕的想法。知识本身是高维的，将其压缩成一维的分数势必会丢失绝大多数的信息，这注定让其相当容易被拟合被 reward hacking（如经典的刷题库）因此应当放弃将考核作为评价标准，日常的能力测定才是其归宿</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>即使已经离开了高中，太多人的一生也还是被困在高考里了，我又何尝不是其中之一呢？</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/699492029">教育的信号传递模型</a></li><li><a href="/2025/11/04/2025-11-04-1/">将带有时间线的知识图谱作为评价标准</a></li></ol>]]></content>
    
    
    <summary type="html">我们的高中，究竟会变成什么样子（哽咽）</summary>
    
    
    
    
    <category term="杂谈" scheme="https://imagebuilder1837.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
    <category term="教育" scheme="https://imagebuilder1837.github.io/tags/%E6%95%99%E8%82%B2/"/>
    
  </entry>
  
  <entry>
    <title>观 Alpha 学校有感</title>
    <link href="https://imagebuilder1837.github.io/2025/11/04/2025-11-04-1/"/>
    <id>https://imagebuilder1837.github.io/2025/11/04/2025-11-04-1/</id>
    <published>2025-11-04T12:13:55.000Z</published>
    <updated>2025-11-04T12:33:39.994Z</updated>
    
    <content type="html"><![CDATA[<h1 id="观-Alpha-学校有感"><a href="#观-Alpha-学校有感" class="headerlink" title="观 Alpha 学校有感"></a>观 Alpha 学校有感</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看了 Thoughts Memo 翻译的 <a href="https://zhuanlan.zhihu.com/p/1962882704082211479">Alpha 学校的介绍</a>，结合前段时间一直在看的学习科学相关内容，感叹道还是有这样把学习科学成果结合进学校的尝试的啊</p><h2 id="学校必须存在"><a href="#学校必须存在" class="headerlink" title="学校必须存在"></a>学校必须存在</h2><p>首先是为什么我认为学校教育必须存在。Wozniak 不送孩子去学校的想法过于不切实际了，理想中的教育应当充分利用学习科学，而这本来就是一门专业知识，不可能做到每个家庭都掌握。就算真的做到了，小家庭专门教育的成本也太高了，要付出父母两人下班后的几乎全部精力（这个家里有在上学的孩子的应该都能理解），就不说总社会成本了，就父母自己来说那累得都叫一个苦不堪言啊。如果衔接上马逆的社会化抚养做到社会化教育，就能省下父母的劳累，发挥集聚效应。另外，在小家庭教育中，无法完成孩子最好的社会化——和一大堆同龄人混成一块。并且你不能假定所有家长都具备把孩子当人的素质，社会化教育可以像社会化抚养一样，识别失格的父母并剥夺其教育权，为不合格家庭的孩子保障一个下限</p><h2 id="社会化不是标准化"><a href="#社会化不是标准化" class="headerlink" title="社会化不是标准化"></a>社会化不是标准化</h2><p>其次是我认为理想学校教育和现有应试教育必须做出的区别。社会化教育不是衡水般的标准化教育，而是充分利用现有学习科学的成果，类似本文和 Math Academy 的路线方向，通过个性化学习系统适应每个人不同的学习情况。还有一个问题也是本文被诟病的考核标准问题，我一直认为教育问题的核心就是考核问题，长期来看教育系统一定会向过拟合考核标准的方向生长（衡水模式就是过拟合高考的结果）。因此我理想中应当放弃所有把高维知识维度压缩为一维分数的考核标准（丢弃掉这么多信息也太好拟合了），纯粹把“掌握的知识”本身作为结果呈现。具体而言，就是 Math Academy 的知识图谱，密密麻麻铺着知识点，颜色越深掌握越扎实的那个网状图本身作为学生学习成果的呈现，只不过是扩展到了数学以外的其他学科。哪些知识点是什么熟练度，不言而喻，一目了然，比什么考试标准都好用。还能在知识图谱的基础上再扩展一下，作为评价标准的知识图谱本身还可以附上时间线，这样就能清晰看到学生数年的成长路线了。相比只能反映学生某一时间点的“考核”，清晰展现出学生不同时间段不同水平的时间线版知识图谱显然更适合作为评价标准</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>总而言之，这还真是往我理想中的学校制度迈出了一大步，我也乐于观察这种模式后续的发展。人活久了还真会看到好事发生啊（叹）</p>]]></content>
    
    
    <summary type="html">有一说一这还真是我理想中学校应该成为的大致方向</summary>
    
    
    
    
    <category term="杂谈" scheme="https://imagebuilder1837.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
    <category term="教育" scheme="https://imagebuilder1837.github.io/tags/%E6%95%99%E8%82%B2/"/>
    
  </entry>
  
  <entry>
    <title>沉默魔女第 11 集感想</title>
    <link href="https://imagebuilder1837.github.io/2025/09/21/2025-09-21-1/"/>
    <id>https://imagebuilder1837.github.io/2025/09/21/2025-09-21-1/</id>
    <published>2025-09-21T07:29:03.000Z</published>
    <updated>2025-09-21T08:11:27.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="沉默魔女第-11-集感想"><a href="#沉默魔女第-11-集感想" class="headerlink" title="沉默魔女第 11 集感想"></a>沉默魔女第 11 集感想</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>沉默魔女前面几集基本上就是个正常的孤独波奇风傲天故事，没想到这两集突然整出了段相当酸爽的关系性，给我吃爽了😊</p><h2 id="关系性"><a href="#关系性" class="headerlink" title="关系性"></a>关系性</h2><p>一次再普通不过的伸出援手的开端，逐渐塑造了两人的支配欲与依附感。但因恐惧实力对比变化导致的权力关系变化，他践踏，她承受。他将断绝的话语作为数年前离别与数年后重逢的赠礼，她数年的成长也让她能够说出“不再期待”来与过去做个了结。可最后呢？巧合的互相拯救之后，暗藏着“永远意识着我”和“永远感谢着你”的离别，不还是抽刀断水的往昔吗？太扭曲了😭太美味了😋（虽然但是这好像就是 PUA 和🐢……算了不能细想）</p><p><img src="/images/2025-09-21-1-01.jpeg" alt="2025-09-21-1-01.jpeg"></p><p><img src="/images/2025-09-21-1-02.jpeg" alt="2025-09-21-1-02.jpeg"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>附：湿身.jpg</p><p><img src="/images/2025-09-21-1-03.jpeg" alt="2025-09-21-1-03.jpeg"></p>]]></content>
    
    
    <summary type="html">这季度吃的最好的一对🥰</summary>
    
    
    
    
    <category term="动画" scheme="https://imagebuilder1837.github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
    <category term="沉默魔女的秘密" scheme="https://imagebuilder1837.github.io/tags/%E6%B2%89%E9%BB%98%E9%AD%94%E5%A5%B3%E7%9A%84%E7%A7%98%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>《魔法少女的魔女审判》一周目简评</title>
    <link href="https://imagebuilder1837.github.io/2025/08/30/2025-08-30-1/"/>
    <id>https://imagebuilder1837.github.io/2025/08/30/2025-08-30-1/</id>
    <published>2025-08-30T03:25:54.000Z</published>
    <updated>2025-09-21T02:37:57.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《魔法少女的魔女审判》一周目简评"><a href="#《魔法少女的魔女审判》一周目简评" class="headerlink" title="《魔法少女的魔女审判》一周目简评"></a>《魔法少女的魔女审判》一周目简评</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一周目完结，ご馳走様😋</p><h2 id="简评"><a href="#简评" class="headerlink" title="简评"></a>简评</h2><p>总体可以说是魔法少女版弹丸论破，操作简化了不少（省去了弹丸的神必小游戏，也没有子弹打发言而是直接从发言中延伸出选项）</p><p>推理要素上引入了“魔法”这个因素，好处是可能性空间极大扩展了，虽然一开始会有吐槽“这种 fw 魔法能干嘛”的情况，但当以为没用的 fw 魔法真的和案件情况关联起来的时候反而令人拍案叫绝；坏处是魔法的加入使得有时候逻辑跳跃性太大了，会出现“怎么突然扯到这边”的破坏沉浸感的情况（某一个本来剧情上很重要的案子，我就因为这个从一半开始后面一直没跟上）</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>剧情很好吃，结局很致郁，但二周目似乎和一周目完全不同，待我再去探探🫡</p>]]></content>
    
    
    <summary type="html">呜呜呜我的艾玛酱🥰</summary>
    
    
    
    
    <category term="游戏" scheme="https://imagebuilder1837.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="魔法少女的魔女审判" scheme="https://imagebuilder1837.github.io/tags/%E9%AD%94%E6%B3%95%E5%B0%91%E5%A5%B3%E7%9A%84%E9%AD%94%E5%A5%B3%E5%AE%A1%E5%88%A4/"/>
    
  </entry>
  
  <entry>
    <title>GQuuuuuuX 第十集观后感</title>
    <link href="https://imagebuilder1837.github.io/2025/06/11/2025-06-11-1/"/>
    <id>https://imagebuilder1837.github.io/2025/06/11/2025-06-11-1/</id>
    <published>2025-06-11T04:02:06.000Z</published>
    <updated>2025-09-21T02:37:57.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GQuuuuuuX-第十集观后感"><a href="#GQuuuuuuX-第十集观后感" class="headerlink" title="GQuuuuuuX 第十集观后感"></a>GQuuuuuuX 第十集观后感</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>既然只是看完之后随手写的碎碎念那就不搞那么正式了直接开始（懒）</p><h2 id="三人行，一定行"><a href="#三人行，一定行" class="headerlink" title="三人行，一定行"></a>三人行，一定行</h2><p>之前看 GQuuuuuuX 的时候感觉修司没塑造这点是个遗憾，现在看来反而是一个巧妙的设计。观众觉得修司神秘，玛秋和喵安也觉得修司神秘，但他就该保持这幅神神秘秘的样子，这反而给予了周围人对他无穷的阐释空间</p><p>玛秋和喵安本就相当不同，在短暂的与修司及彼此的交错之后，两人的轨迹像个 X 一样又渐行渐远。原本<del>意林读多了</del>过着普通生活追求机油的玛秋，在去过地球以及和绿叔叔的探讨后，对自由有了进一步的理解（虽然绿叔叔讲木星经历那段，我看的是有点迷惑的，但管他呢看就对了）；难民出身的喵安，在失去修司的破碎后，又遇到了对力量有着执着理解的紫色老太婆，亲手启动了尤玛恩托干掉了整个阿巴瓦空。现如今的她们两人会而且必定会对修司——这个对她们而言模糊而又无比重要的人做出自己的阐释，并在高达机体的对撞和两把契诃夫之枪的对决中达到冲突的顶峰</p><p>且看下集《修司：孩子们，我回来了》</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>居然要同时致敬鲁路修和鬼泣吗，鹤基米，你这家伙👍</p>]]></content>
    
    
    <summary type="html">一想到接下来我要看到什么就想笑😁</summary>
    
    
    
    
    <category term="动画" scheme="https://imagebuilder1837.github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
    <category term="高达" scheme="https://imagebuilder1837.github.io/tags/%E9%AB%98%E8%BE%BE/"/>
    
    <category term="GQuuuuuuX" scheme="https://imagebuilder1837.github.io/tags/GQuuuuuuX/"/>
    
  </entry>
  
  <entry>
    <title>VSCode C 语言环境配置（Windows）</title>
    <link href="https://imagebuilder1837.github.io/2025/03/26/2025-03-26-2/"/>
    <id>https://imagebuilder1837.github.io/2025/03/26/2025-03-26-2/</id>
    <published>2025-03-26T12:41:59.000Z</published>
    <updated>2025-09-21T02:37:57.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VSCode-C-语言环境配置（Windows）"><a href="#VSCode-C-语言环境配置（Windows）" class="headerlink" title="VSCode C 语言环境配置（Windows）"></a>VSCode C 语言环境配置（Windows）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>模型与算法实验课居然用十年前的 Dev-C++ 配置环境😓居然还真有同学运行出了兼容性问题（大概是？看了半天也没发现他代码有什么问题，结果一到我的环境中就正常运行了），遂向老师提交建议安利 VSCode + WinLibs</p><h2 id="为什么要改进现有的-C-语言环境配置"><a href="#为什么要改进现有的-C-语言环境配置" class="headerlink" title="为什么要改进现有的 C 语言环境配置"></a>为什么要改进现有的 C 语言环境配置</h2><ul><li>目前实验项目书中使用 Dev-C++ 配置 C 语言环境，虽然目的是为了提供一键式操作，但这反而遮蔽了具体的配置细节</li><li>目前的环境配置教学只是老师指挥着安装了软件，对 C 语言编译器、C 语言调试器、代码编辑器等概念基本没有介绍，导致大伙对配置环境具体意味着什么一无所知，出现问题时难以寻找解决方案</li><li>Dev-C++ 最后一版发布于 2015 年，使用的 GCC 版本为 4.9.2，已严重落后于实际的开发环境。作为参考，截至目前（2025 年 3 月 26 日）WinLibs 使用的 GCC 版本为 14.2.0</li></ul><h2 id="为什么使用-VSCode-WinLibs-作为替代方案"><a href="#为什么使用-VSCode-WinLibs-作为替代方案" class="headerlink" title="为什么使用 VSCode + WinLibs 作为替代方案"></a>为什么使用 VSCode + WinLibs 作为替代方案</h2><ul><li>VSCode 是纯粹的代码编辑器，并非如 Dev-C++ 的 IDE，能暴露出更多的配置细节，让人对代码究竟是如何从编写到运行的整个生命周期有更清晰的认知</li><li>正因为 VSCode 是纯粹的代码编辑器，其能够轻易的跨语言，在学习其他诸如数字图像处理等使用 Python 的课程时不需要更换代码编辑器，不像现有的方案一个语言一个编辑器（C 要装 Dev-C++，Python 又要装 PyCharm）</li><li>WinLibs 基于 Mingw-w64 提供了一条完整的、可定制的开源 C 和 C++ 编译工具链，是 Windows 下相对完整的 GCC 环境</li><li>WinLibs 以压缩包形式提供，解压并添加环境变量即可使用，容易上手</li></ul><h2 id="环境配置教学目标"><a href="#环境配置教学目标" class="headerlink" title="环境配置教学目标"></a>环境配置教学目标</h2><p>这是一图流</p><p><img src="/images/2025-03-26-2-01.jpeg" alt="2025-03-26-2-01.jpeg"></p><p>环境配置教学应该让人理解如下概念：</p><ol><li>可执行文件：就是平时你运行的 exe 程序（严格来说这说法不准确，但暂时不用管），它们都是由编译器编译代码文件生成的（但不一定是 C 语言）</li><li>代码文本文件：除了后缀不同和 txt 文本文件没有任何区别，甚至你可以直接用记事本打开在里面写代码，写完丢给 C 语言编译器就能直接编译成可执行文件</li><li>C 语言编译器：C 语言编译器将 C 语言代码文件编译成可执行文件。GCC 和 LLVM&#x2F;Clang 是两种主流的 C 语言编译器，一般而言开源项目和教学用途倾向使用 GCC，商业项目倾向使用 LLVM&#x2F;Clang。本文使用 WinLibs 打包的 GCC 编译器，在终端中输入 <code>gcc xxx.c -o xxx.exe</code> 即可将 C 语言代码文件编译成可执行文件（所以理论上你不需要任何诸如 VSCode 或 Dev-C++ 的代码编辑器照样能编写并运行 C 语言程序）</li><li>C 语言调试器：能让你观察程序运行时究竟发生了什么的工具，代码有 bug 时可使用调试器给程序打断点并一步步调试找出问题所在，GDB 是常用的 C 语言调试器</li><li>MinGW-w64：GCC 是主要适用于 Linux 系统的编译器，MinGW-w64 项目为 GCC 与相关工具链提供了 Windows 支持</li><li>WinLibs：是 MinGW-w64 的一个独立构建版本，在 MinGW-w64 的基础上添加了 CMake 等常用工具，使开发环境更加完整易用</li><li>VSCode 代码编辑器：只是一个更漂亮、功能更多的记事本而已（x）</li><li>VSCode 扩展插件：VSCode 本身功能并不多，但装什么扩展插件就有什么功能。比如装了 C&#x2F;C++ 扩展插件就能写 C 和 C++，装了 Python 扩展插件就能写 Python，装了 Markdown All In One 就能写 Markdown，装了 Remote Development 套件就能远程连接 SSH、Tunnel、WSL、Docker 甚至 GitHub 仓库……总之只有想不到，没有 VSCode 扩展插件做不到</li></ol><h2 id="用到的软件-网站"><a href="#用到的软件-网站" class="headerlink" title="用到的软件&#x2F;网站"></a>用到的软件&#x2F;网站</h2><ul><li><a href="https://winlibs.com/">WinLibs</a>：为 Windows 平台提供 GCC 和 MinGW-w64 工具链的项目，旨在帮助开发者轻松构建和开发 C&#x2F;C++ 应用程序</li><li><a href="https://sourceforge.net/">SourceForge</a>：知名的开源项目托管和分发平台，为全球开发者和用户提供大量的开源软件下载和协作开发服务</li><li><a href="https://code.visualstudio.com/">Visual Studio Code</a>：微软开发的轻量级、功能强大的代码编辑器，通过数量庞大的扩展插件支持绝大部分编程语言的开发</li><li><a href="https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hans">Chinese (Simplified) (简体中文) Language Pack for Visual Studio Code</a>：提供中文界面的 VSCode 插件</li><li><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">C&#x2F;C++ for Visual Studio Code</a>：提供 C&#x2F;C++ 语法支持的 VSCode 扩展插件</li><li><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner">Code Runner</a>：通过快捷键触发构建命令，从而实现 <code>Ctrl + Alt + N</code> 一键运行多种语言代码文件的 VSCode 扩展插件</li></ul><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h3 id="WinLibs-下载配置"><a href="#WinLibs-下载配置" class="headerlink" title="WinLibs 下载配置"></a>WinLibs 下载配置</h3><ol><li>WinLibs 官方网站的下载链接是通往 GitHub 的，如果没有特殊网络环境的话下载速度相当慢，因此可以下载 <a href="https://sourceforge.net/projects/winlibs-mingw/files/">WinLibs 在 SourceForge 上的托管</a>，选择最新发布的带有“posix”的版本（win32 版本缺少一些东西，mcf 版本不常用）</li></ol><p><img src="/images/2025-03-26-2-02.jpeg" alt="2025-03-26-2-02.jpeg"></p><ol start="2"><li>哇袄！琳琅满目的下载链接！这该怎么选？首先，i686 是给 32 位计算机用的，现在的个人电脑基本都是 64 位了，从带“x86_64”的里面选；其次，我们只用 GCC，带“llvm”的不用选；最后剩下的文件里有两个体积明显更大的，这两个压缩包只是格式不同，内容完全一样，随便选一个下载就行</li></ol><p><img src="/images/2025-03-26-2-03.jpeg" alt="2025-03-26-2-03.jpeg"></p><ol><li>下载完压缩包解压后是一个名为“mingw64”的文件夹，把这个文件夹放到一个安分的位置（比如我把它放到我在 C 盘建的 bin 文件夹）</li></ol><p><img src="/images/2025-03-26-2-04.jpeg" alt="2025-03-26-2-04.jpeg"></p><ol start="4"><li>在 Windows 搜索框中搜索“env”，按如下步骤把 mingw64 文件夹下的 bin 文件夹（比如我是 C:\bin\mingw64\bin）添加至 Path 环境变量</li></ol><p><img src="/images/2025-03-26-2-05.jpeg" alt="2025-03-26-2-05.jpeg"></p><p><img src="/images/2025-03-26-2-06.jpeg" alt="2025-03-26-2-06.jpeg"></p><ol start="5"><li>打开终端（或 PowerShell、命令提示符（cmd）），通过 <code>--version</code> 选项验证 GCC 是否可成功被终端调用（输出版本号即为成功）</li></ol><p><img src="/images/2025-03-26-1-04.jpeg" alt="2025-03-26-1-04.jpeg"></p><p><img src="/images/2025-03-26-2-07.jpeg" alt="2025-03-26-2-07.jpeg"></p><h3 id="VSCode-安装配置"><a href="#VSCode-安装配置" class="headerlink" title="VSCode 安装配置"></a>VSCode 安装配置</h3><ol><li>前往 <a href="https://code.visualstudio.com/">VSCode 官方网站</a> 下载 VSCode 安装程序</li></ol><p><img src="/images/2025-03-26-1-06.jpeg" alt="2025-03-26-1-06.jpeg"></p><ol start="2"><li>运行 VSCode 安装程序，一般按照默认选项即可，需要注意的选项如下</li></ol><p><img src="/images/2025-03-26-1-07.jpeg" alt="2025-03-26-1-07.jpeg"></p><ol><li>打开 VSCode，选择左侧 Extensions 页面，搜索“chinese”安装中文扩展插件，安装完毕并重启后 VSCode 即为中文界面</li></ol><p><img src="/images/2025-03-26-1-08.jpeg" alt="2025-03-26-1-08.jpeg"></p><ol start="4"><li>同理，搜索“c&#x2F;c++”安装 C 和 C++ 语法支持扩展插件，搜索“code runner”安装快捷运行扩展插件</li></ol><p><img src="/images/2025-03-26-2-00.jpeg" alt="2025-03-26-2-00.jpeg"></p><p><img src="/images/2025-03-26-1-09.jpeg" alt="2025-03-26-1-09.jpeg"></p><ol start="5"><li>打开 Code Runner 扩展设置，勾选“Run In Terminal”选项，让 Code Runner 在 VSCode 终端中运行命令</li></ol><p><img src="/images/2025-03-26-2-08.jpeg" alt="2025-03-26-2-08.jpeg"></p><ol start="6"><li>打开 C 语言源代码文件，通过快捷键 <code>Ctrl + Alt + N</code> 或点击右上的小三角即可运行单个 C 程序</li></ol><p><img src="/images/2025-03-26-2-09.jpeg" alt="2025-03-26-2-09.jpeg"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>初高中信竞用的就是 Dev-C++，上了大学居然还能继续见到。Dev-C++ 最后一版发布都十年了，大学课程更新还真是慢啊</p>]]></content>
    
    
    <summary type="html">VSCode 真好用吧 × 2</summary>
    
    
    
    
    <category term="编程" scheme="https://imagebuilder1837.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="VSCode" scheme="https://imagebuilder1837.github.io/tags/VSCode/"/>
    
    <category term="C 语言" scheme="https://imagebuilder1837.github.io/tags/C-%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>VSCode Python 环境配置（Windows）</title>
    <link href="https://imagebuilder1837.github.io/2025/03/26/2025-03-26-1/"/>
    <id>https://imagebuilder1837.github.io/2025/03/26/2025-03-26-1/</id>
    <published>2025-03-26T12:23:09.000Z</published>
    <updated>2025-09-21T02:37:57.175Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VSCode-Python-环境配置（Windows）"><a href="#VSCode-Python-环境配置（Windows）" class="headerlink" title="VSCode Python 环境配置（Windows）"></a>VSCode Python 环境配置（Windows）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>数字图像处理实验课需要配置 Python 的 OpenCV 环境，给的实验报告书是用 PyCharm 和 Anaconda，发现相当多同学配环境配得焦头烂额，于是趁机向老师安利 VSCode</p><h2 id="为什么要改进现有的-Python-环境配置"><a href="#为什么要改进现有的-Python-环境配置" class="headerlink" title="为什么要改进现有的 Python 环境配置"></a>为什么要改进现有的 Python 环境配置</h2><ul><li>目前实验项目书中使用重型 IDE PyCharm 与 Anaconda 配置 Python 环境，虽然目的是为了提供一键式操作，但这反而遮蔽了具体的配置细节</li><li>目前的环境配置教学只是老师指挥着安装了两三个软件，对 Python 解释器、Python 包管理、代码编辑器等概念基本没有介绍，导致大伙对配置环境具体意味着什么一无所知，出现问题时难以寻找解决方案</li><li>课程代码并不涉及复杂的软件工程，无法发挥 PyCharm 作为重型 IDE 的优势，反而需要承受 PyCharm 过于笨重的代价</li></ul><h2 id="为什么使用-VSCode-作为替代方案"><a href="#为什么使用-VSCode-作为替代方案" class="headerlink" title="为什么使用 VSCode 作为替代方案"></a>为什么使用 VSCode 作为替代方案</h2><ul><li>VSCode 是纯粹的代码编辑器，并非如 PyCharm 的重型 IDE，能暴露出更多的配置细节，让人对代码究竟是如何从编写到运行的整个生命周期有更清晰的认知</li><li>正因为 VSCode 是纯粹的代码编辑器，其能够轻易的跨语言，在学习其他诸如模型与算法等使用 C 语言的课程时不需要更换代码编辑器，不像现有的方案一个语言一个编辑器（Python 要装 PyCharm，C 又要装 Dev-C++）</li></ul><h2 id="环境配置教学目标"><a href="#环境配置教学目标" class="headerlink" title="环境配置教学目标"></a>环境配置教学目标</h2><p>这是一图流</p><p><img src="/images/2025-03-26-1-01.jpeg" alt="2025-03-26-1-01.jpeg"></p><p>环境配置教学应该让人理解如下概念：</p><ol><li>代码文本文件：除了后缀不同和 txt 文本文件没有任何区别，甚至你可以直接用记事本打开在里面写代码，写完丢给 Python 解释器就能直接运行</li><li>Python 解释器：在终端中输入 <code>python</code> 打开的就是 Python 解释器，在终端中输入 <code>python xxx.py</code> 就能直接运行 Python 代码文件（所以理论上你不需要任何诸如 VSCode 或 PyCharm 的代码编辑器照样能编写并运行 Python 程序）</li><li>Python 包：除了 Python 自带的标准库，其他需要你 <code>import</code> 的软件包基本都不会默认安装到你的电脑，需要通过 pip 包管理器下载</li><li>PyPI 包仓库：托管绝大多数的 Python 包的网站，pip 默认就从这个网站下载 Python 包，但因为服务器位于国外所以下载速度相当慢</li><li>PyPI 镜像站：为了解决下载慢的问题，由国内好心人搭建的 Python 包托管网站，通常每过数个小时就会重新从 PyPI 把 Python 包同步过来一遍，因为服务器在国内所以下载速度明显提升。其中<a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站</a>是最知名的镜像站</li><li>pip 包管理器：通过终端使用的下载并管理你电脑上 Python 包的工具，常用命令如下<ol><li><code>pip config set global.index-url https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple</code>：将 pip 默认下载路径设置成清华源</li><li><code>pip install some_package</code>：从默认下载路径下载名为 some_package 的 Python 包并安装到你的电脑</li><li><code>pip uninstall some_package</code>：从你的电脑中卸载名为 some_package 的 Python 包</li><li><code>pip list</code>：查看你电脑中已安装的 Python 包</li></ol></li><li>VSCode 代码编辑器：只是一个更漂亮、功能更多的记事本而已（x）</li><li>VSCode 扩展插件：VSCode 本身功能并不多，但装什么扩展插件就有什么功能。比如装了 Python 扩展插件就能写 Python，装了 C&#x2F;C++ 扩展插件就能写 C 和 C++，装了 Markdown All In One 就能写 Markdown，装了 Remote Development 套件就能远程连接 SSH、Tunnel、WSL、Docker 甚至 GitHub 仓库……总之只有想不到，没有 VSCode 扩展插件做不到</li></ol><h2 id="用到的软件-网站"><a href="#用到的软件-网站" class="headerlink" title="用到的软件&#x2F;网站"></a>用到的软件&#x2F;网站</h2><ul><li><a href="https://www.python.org/">Python</a>：简单易学、功能强大、应用广泛的高级编程语言，具有简洁的语法、丰富的库和跨平台的特性</li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站</a>：清华大学提供的，涵盖大量主流开源项目的镜像资源的，安全、稳定、快速的开源软件镜像下载服务</li><li><a href="https://code.visualstudio.com/">Visual Studio Code</a>：微软开发的轻量级、功能强大的代码编辑器，通过数量庞大的扩展插件支持绝大部分编程语言的开发</li><li><a href="https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hans">Chinese (Simplified) (简体中文) Language Pack for Visual Studio Code</a>：提供中文界面的 VSCode 扩展插件</li><li><a href="https://marketplace.visualstudio.com/items?itemName=ms-python.python">Python extension for Visual Studio Code</a>：提供 Python 语法支持的 VSCode 扩展插件</li><li><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner">Code Runner</a>：通过快捷键触发构建命令，从而实现 <code>Ctrl + Alt + N</code> 一键运行多种语言代码文件的 VSCode 扩展插件</li></ul><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h3 id="Python-安装配置"><a href="#Python-安装配置" class="headerlink" title="Python 安装配置"></a>Python 安装配置</h3><ol><li>前往 <a href="https://www.python.org/">Python 官方网站</a> 下载 Python 安装程序</li></ol><p><img src="/images/2025-03-26-1-02.jpeg" alt="2025-03-26-1-02.jpeg"></p><ol start="2"><li>运行 Python 安装程序，一般按照默认选项即可，需要注意的选项如下</li></ol><p><img src="/images/2025-03-26-1-03.jpeg" alt="2025-03-26-1-03.jpeg"></p><ol start="3"><li>打开终端（或 PowerShell、命令提示符（cmd）），通过 <code>--version</code> 选项验证 Python 和 pip 是否成功安装（输出版本号即为成功）</li></ol><p><img src="/images/2025-03-26-1-04.jpeg" alt="2025-03-26-1-04.jpeg"></p><p><img src="/images/2025-03-26-1-05.jpeg" alt="2025-03-26-1-05.jpeg"></p><ol start="4"><li>按照 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/">清华大学开源软件镜像站 pypi 使用帮助</a>，通过命令 <code>pip config set global.index-url https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple</code> 让 pip 默认从清华源下载 Python 包</li></ol><h3 id="VSCode-安装配置"><a href="#VSCode-安装配置" class="headerlink" title="VSCode 安装配置"></a>VSCode 安装配置</h3><ol><li>前往 <a href="https://code.visualstudio.com/">VSCode 官方网站</a> 下载 VSCode 安装程序</li></ol><p><img src="/images/2025-03-26-1-06.jpeg" alt="2025-03-26-1-06.jpeg"></p><ol start="2"><li>运行 VSCode 安装程序，一般按照默认选项即可，需要注意的选项如下</li></ol><p><img src="/images/2025-03-26-1-07.jpeg" alt="2025-03-26-1-07.jpeg"></p><ol start="3"><li>打开 VSCode，选择左侧 Extensions 页面，搜索“chinese”安装中文扩展插件，安装完毕并重启后 VSCode 即为中文界面</li></ol><p><img src="/images/2025-03-26-1-08.jpeg" alt="2025-03-26-1-08.jpeg"></p><ol start="4"><li>同理，搜索“python”安装 Python 语法支持扩展插件，搜索“code runner”安装快捷运行扩展插件</li></ol><p><img src="/images/2025-03-26-1-00.jpeg" alt="2025-03-26-1-00.jpeg"></p><p><img src="/images/2025-03-26-1-09.jpeg" alt="2025-03-26-1-09.jpeg"></p><ol start="5"><li>打开 Code Runner 扩展设置，勾选“Run In Terminal”选项，让 Code Runner 在 VSCode 终端中运行命令</li></ol><p><img src="/images/2025-03-26-1-10.jpeg" alt="2025-03-26-1-10.jpeg"></p><ol start="6"><li>打开 Python 源代码文件，通过快捷键 <code>Ctrl + Alt + N</code> 或点击右上的小三角即可运行单个 Python 程序</li></ol><p><img src="/images/2025-03-26-1-11.jpeg" alt="2025-03-26-1-11.jpeg"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>现在环境配置教学对“其中发生了什么”教的还是太少了😓</p>]]></content>
    
    
    <summary type="html">VSCode 真好用吧</summary>
    
    
    
    
    <category term="编程" scheme="https://imagebuilder1837.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="VSCode" scheme="https://imagebuilder1837.github.io/tags/VSCode/"/>
    
    <category term="Python" scheme="https://imagebuilder1837.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>TEE 损坏修复教程</title>
    <link href="https://imagebuilder1837.github.io/2025/02/07/2025-02-07-1/"/>
    <id>https://imagebuilder1837.github.io/2025/02/07/2025-02-07-1/</id>
    <published>2025-02-07T09:23:19.000Z</published>
    <updated>2025-09-21T02:37:57.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TEE-损坏修复教程"><a href="#TEE-损坏修复教程" class="headerlink" title="TEE 损坏修复教程"></a>TEE 损坏修复教程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大半夜里正刷机刷着玩的机佬，或许是过于手贱，不幸作死乱动了 persist 分区，机佬的手机因此获得无法恢复的 TEE 损坏。对此，给出的惩罚居然是……给我整晚地找办法修啊，三回啊三回！</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>根据<a href="https://www.coolapk.com/feed/42576990">酷安@Dogggee 的帖子</a>介绍，TEE 即手机的可信执行环境，是古希腊掌管生物信息和指纹支付的神。某些谷歌应用会验证 TEE 的环境，如果检测到 TEE 损坏直接拒绝启动。虽然国内的应用较少依赖 TEE，但如果这个模块损坏，相当于 APP 能直接读取手机中存储的生物信息，四舍五入你的指纹信息就相当于是裸奔了</p><p>TEE 损坏分为假死和真死。假死是指可逆的 TEE 损坏，例如某些厂商（如蓝厂）解锁后会自动损坏 TEE，回锁即可自动修复；又比如一些隐藏 BL 锁的模块也会导致 TEE 损坏，卸载模块即可解决。真死一般只会是动了原厂 persist 分区才会出现，真死的 TEE 损坏是不可逆的，通常意义上的修复方法也只是写入其他设备的密钥文件使 TEE 假性恢复</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p><strong>叠甲时间：本文所述恢复方法仅作为自己恢复经历的记录，不保证在其他情况下能完全复现成功。刷机会清除所有数据，还需谨慎操作</strong></p><p>恢复 TEE 需要先准备好以下三个素材：</p><ol><li>对应机型工程包：这类包通常带有诸如“eng_firmware”之类的标识，酷安对应机型的讨论区通常会有分享</li><li>对应机型官方系统包：顾名思义，即对应机型官方提供的刷机包</li><li>有效 keybox：即用于恢复 TEE 的 xml 密钥文件，一般网上流传的有些时日的 keybox 都会被谷歌吊销而无效化，可以在酷安上碰运气翻翻，说不定就能翻到好心人分享的还新鲜有效的 keybox 呢（亲身经历）</li></ol><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>将手机重启至 fastboot 模式</li><li>通过 <code>fastboot oem edl</code> 进入 9008 模式</li><li>使用<a href="https://lsdy.top/gjzs">搞机助手</a>的 9008 刷机模式刷入工程包（理论上高通官方的 <a href="https://qpsttool.com/">QPST</a> 应该也行，但我试了没成功）</li><li>刷入工程包后我这台机器 BootLoader 被重新锁定，使用小米解锁工具解锁 BootLoader</li><li>解压缩官方系统包并复制出其中的 <code>persist.img</code>（如果是卡刷包则可能需要使用 <a href="https://github.com/vm03/payload_dumper">payload_dumper</a> 解包卡刷包中的 <code>payload.bin</code> 文件得到）</li><li>将从系统包中提取的 <code>persist.img</code> 刷入 persist 分区</li><li>重启进入工程系统，在设置中连击系统版本号进入开发者选项，开启 USB 调试选项</li><li>通过 adb 输入以下命令：</li></ol><pre><code class="powershell">adb rootadb disable-verityadb rebootadb rootadb remountadb shell mkdir -p /data/nativetest64/qti_keymaster_tests/adb push keybox.xml /data/nativetest64/qti_keymaster_tests/adb shell LD_LIBRARY_PATH=/vendor/lib64/hw KmInstallKeybox /data/nativetest64/qti_keymaster_tests/keybox.xml &lt;DeviceID&gt; true# 其中的 &lt;DeviceID&gt; 在 keybox xml 文件头部，可通过文本编辑器打开发现</code></pre><ol start="9"><li>重启至 fastboot 刷入官方系统包（如果是卡刷包则需要先刷入第三方 recovery 如 <a href="https://twrp.me/">TWRP</a>，再重启至 recovery 中刷入）</li></ol><p>如果你的 keybox 是有效的，<a href="https://github.com/vvb2060/KeyAttestation">密钥认证</a>检测应该就能显示正常了。哦没跌多！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.coolapk.com/feed/53401471">酷安@Yz_阳子 的教程</a></li><li><a href="https://github.com/chiteroman/Reprogram-TEE-on-Qualcomm-devices">Reprogram-TEE-on-Qualcomm-devices</a></li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>最大的感想：刷机的时候千万不要手贱作死乱动分区💀</p>]]></content>
    
    
    <summary type="html">修复损坏的 TEE</summary>
    
    
    
    
    <category term="数码" scheme="https://imagebuilder1837.github.io/tags/%E6%95%B0%E7%A0%81/"/>
    
    <category term="刷机" scheme="https://imagebuilder1837.github.io/tags/%E5%88%B7%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>回顾马前卒和傅正关于“左宗棠解放新疆”的争论</title>
    <link href="https://imagebuilder1837.github.io/2024/02/22/2024-02-22-1/"/>
    <id>https://imagebuilder1837.github.io/2024/02/22/2024-02-22-1/</id>
    <published>2024-02-22T09:02:49.000Z</published>
    <updated>2025-09-21T02:37:57.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回顾马前卒和傅正关于“左宗棠解放新疆”的争论"><a href="#回顾马前卒和傅正关于“左宗棠解放新疆”的争论" class="headerlink" title="回顾马前卒和傅正关于“左宗棠解放新疆”的争论"></a>回顾马前卒和傅正关于“左宗棠解放新疆”的争论</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>又看了一遍米大统领的<a href="https://www.bilibili.com/video/BV14W4y1F7p7/">马前卒人物志</a>，一时兴起去翻了翻 21 年末马前卒和傅正的争论，感觉米大统领总结的还是略微有失偏颇，就忍不住自己总结了一番，如有不同观点还请批评指正</p><h2 id="“解放”的词性"><a href="#“解放”的词性" class="headerlink" title="“解放”的词性"></a>“解放”的词性</h2><p>回顾了一遍马前卒和傅正关于“解放”的争论，马前卒的观点出发点是<a href="https://t.bilibili.com/608907211598739547">“左宗棠解放新疆”这句话里用“解放”不成立</a>，但很快战场就被双方拉到讨论<a href="https://t.bilibili.com/609546547544640514">“民族解放运动”用“解放”是否合适</a>了。但实际上这两个“解放”词性并不一致，作为名词的“解放”相较动词形式使用频率较高，相对而言使用场景会更加多样，难以准确定义。就我观察，在日常语境中动词形式的“解放”会更偏向马前卒的观点，即专指 1949 年胜利的解放战争，而名词形式的“解放”因为使用场景的多样，含义的平均值也更偏广义而非狭义的一边，傅正坚持的“民族解放运动”是正常且普遍被认可的说法</p><h2 id="战场分析"><a href="#战场分析" class="headerlink" title="战场分析"></a>战场分析</h2><p>所以我认为讨论争执不下的原因很重要一点在于战场被拉到了含义更广泛的名词形式一边，而名词一边的战场是相当不利于马前卒想对“解放”做精确定义，更不利于他将“解放”的含义仅仅限定在“解放战争”的含义中的。讨论后期能观察到马前卒似乎隐约感觉到有哪里不对，自己也提出了<a href="https://t.bilibili.com/610015291684400973">“光绪亲征新疆算不算解放新疆”</a>的命题，把讨论往动词形式方向回拉了一点，但因为马前卒自己也没有明确提出名词和动词的区别，没有做出切割（我猜他自己其实也没搞清词性不同导致的问题）所以很快他又被拉到名词一边对线去了（甚至讨论到<a href="https://t.bilibili.com/610041009952011341">性解放</a>这种十万八千里远的地方去了</p><h2 id="史书"><a href="#史书" class="headerlink" title="史书"></a>史书</h2><p>米大统领的视频介绍这场争论时认为主要因素是“马克思主义和民族主义之争”，但在我看来民族主义相关的观点冲突对这场讨论的影响有被相当大程度的高估甚至于误解。去看<a href="https://www.bilibili.com/read/cv14638422/">傅正当时所写的专栏</a>可以发现他对“民族解放运动”的认同主要来自于“政治解放民族解放是经济发展的前提”，而非视频所说的“自古以来”这种说法所代表的意识形态，所以在我看来在生产力这个讨论方向上两者的冲突是明显小于马前卒试图在名词领域严格限定“解放”含义造成的冲突的。即使存在，也是马前卒认为“解放”的目标结果必须是达到无产阶级专政，傅正认为只要在生产关系社会制度上相较进步就能称为“解放”，是认同泛马克思主义这个大方向下“绝对”和“相对”之争，而非马克思主义和民族主义的方向之争，对讨论的影响是远不如马前卒被拉进名词领域还在坚持他的严格限定这回事大的。个人认为关于马前卒和傅正的争论应该定性为“泛马克思主义方向未划分词性状态下（马定义没有给出足够精确的定义，但凡切割了名词和动词我认为就不会有那么大争议了）词义限定和词义泛化的冲突”而非“马克思主义与民族主义之争”</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>真没想到水平不低的两位在文字辩论中似乎也没辨析清词性定义啊🤔</p>]]></content>
    
    
    <summary type="html">总感觉他们讨论频道没对齐……</summary>
    
    
    
    
    <category term="杂谈" scheme="https://imagebuilder1837.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>《女神异闻录5皇家版》一周目全成就玩后感</title>
    <link href="https://imagebuilder1837.github.io/2023/12/22/2023-12-22-1/"/>
    <id>https://imagebuilder1837.github.io/2023/12/22/2023-12-22-1/</id>
    <published>2023-12-22T13:43:21.000Z</published>
    <updated>2025-09-21T02:37:57.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《女神异闻录5皇家版》一周目全成就玩后感"><a href="#《女神异闻录5皇家版》一周目全成就玩后感" class="headerlink" title="《女神异闻录5皇家版》一周目全成就玩后感"></a>《女神异闻录5皇家版》一周目全成就玩后感</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇玩后感其实是我暑假的时候写的，只是因为最近太颓废了写不了一点博客于是搬运一篇老文章水一下（</p><p>话不多说，跟我一起喊：“P5R 天下第一！”</p><p><img src="/images/2023-12-22-1-00.jpeg" alt="2023-12-22-1-00.jpeg"></p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>《女神异闻录5皇家版》（简称 P5R），一款被誉为“天下第一”的游戏（奥德赛是天，塞尔达是天外飞仙），一款斩获 IGN、GameSpot 众多媒体满分评价的游戏，一款被评选为“史上最伟大的角色扮演游戏”的 JRPG。本人于 7 月初 Steam 夏促 -40% 入手。从 7 月 5 日第一次启动到 7 月 21 日一周目全成就通关，总游戏时长 130+ 小时，特此评价</p><p><img src="/images/2023-12-22-1-01.jpeg" alt="2023-12-22-1-01.jpeg"></p><h2 id="美术"><a href="#美术" class="headerlink" title="美术"></a>美术</h2><h3 id="主题风格"><a href="#主题风格" class="headerlink" title="主题风格"></a>主题风格</h3><p>P5R 的配色采取了大胆的黑白红三色配色，辅以放荡的字体设计与不对称色块线条的运用，使得 P5R 的美术风格称得上鹤立鸡群，显得极为抓眼（我入坑的很大一部分因素也在于此），也同时表达出了贯穿游戏始终的“反抗”主题</p><h3 id="UI设计"><a href="#UI设计" class="headerlink" title="UI设计"></a>UI设计</h3><p>UI 设计可谓是最能体现 P5R 美术风格的一面。红色主色加黑白辅色冲击的色彩搭配，流畅帅气的转场动画，全程扭动的光标指示条，无一不展现着 P5R 华丽酷炫、放荡不羁的风格</p><p>而 P5R 的 UI 也并没有为了它的风格牺牲实用性。鲜艳的色彩对比中，功能区与美术区有着清晰的分隔；炫酷的转场动画时，显眼的视觉引导线指引着玩家的目光。这使得玩家能在惊艳的美术后快速切换到实用的功能方面，实现了二者的统一</p><h3 id="探索设计"><a href="#探索设计" class="headerlink" title="探索设计"></a>探索设计</h3><p>在 P5R 的世界中，人的潜意识实体化成了“异世界”，主角团也正是在这些夸张的扭曲中进行着探索与战斗</p><p>殿堂是游戏的战斗主线，象征着其主人扭曲的欲望。从鸭志田诡异阴森的古堡，到班目虚荣华丽的美术馆，到奥村全年无休的宇宙工厂，再到狮童傲慢辉煌的豪华游轮，P5R 迷宫的美术设计对人物内心的展现不得不令人拍案叫绝</p><p>印象空间是一个独立的战斗场所，象征着所有人共同的集体无意识。从入口的地铁站一路向下，从最初稍显正常的轨道往深处不可名状的古怪一路疾驶，让人内心中的阴影得以一览无余（还有可爱的小约瑟陪你）</p><h3 id="日常生活"><a href="#日常生活" class="headerlink" title="日常生活"></a>日常生活</h3><p>P5R 中主角因被陷害而被遣送到了东京寄居，东京的各个城区就是主角日常可以活动的范围。P5R 的地图基本上是根据真实的日本 1：1 还原的。你可以在大街上偷听社畜的无奈对话，可以和咖啡店里的评论家探讨社会，可以在吉祥寺的寺院里冥想打坐，可以在棒球击球场为了三个本垒打凹上半个小时（我是带彩笔）。整个日常的氛围令人沉浸其中，仿佛自己真的随着主角一同在东京度过生活一样</p><h3 id="游戏音乐"><a href="#游戏音乐" class="headerlink" title="游戏音乐"></a>游戏音乐</h3><p>这是 P5R 能够让人沉浸其中的另一宝具。无论是白天紧张欢快的 Tokyo Emergency，还是晚上舒缓的 Beneath the Mask，还是探索各个风格相异的殿堂时不同的 BGM（金城殿堂的唢呐至今印象深刻），又或是预告信发出后 boss 战激昂的 Life Will Change，在调动玩家情绪上都发挥了堪称典范的作用</p><h2 id="游戏性"><a href="#游戏性" class="headerlink" title="游戏性"></a>游戏性</h2><h3 id="战斗模式"><a href="#战斗模式" class="headerlink" title="战斗模式"></a>战斗模式</h3><p>P5R 在战斗模式上延续传统的 P 可梦回合制玩法，却一点也不让我这个对宝可梦喜欢不起来的人感到枯燥，实际体验相当优秀。P5R 在普通回合制的基础上增加了倒地 1more、换手、总攻击、showtime 等机制，华丽而不失有效，只要稍加上手熟悉战斗，操作能够变得十分流畅。再配合上丝滑的 UI 与战斗动画演出，P5R 的战斗真的称得上又爽又帅（奥村四大汉给爷爬）</p><h3 id="殿堂探索"><a href="#殿堂探索" class="headerlink" title="殿堂探索"></a>殿堂探索</h3><p>构成 P5R 主线的殿堂抛弃了前作的完全随机生成式迷宫，让每一个殿堂都成了固定的迷宫。于迷宫之中的探索因敌人的存在保持着适度的紧张感（虽然到了后期刷够了等级都是一路创过去），各个迷宫的解谜也都属于“要动脑，稍微动些脑确实就能过去”的程度，个人体感非常友好，没有因为解谜卡关去抄攻略的情况出现。收集要素方面，P5R 的地图非常友好，会自动帮你标红没有探索过的地方。只要每次都保证探索到地图上全白就不会出现漏东西的情况</p><h3 id="印象空间"><a href="#印象空间" class="headerlink" title="印象空间"></a>印象空间</h3><p>P 系列前作的随机迷宫传承给了 P5R 的印象空间。这里是平时接到的支线委托任务出现的地方，也是心之强盗团开着猫车一路创钱和经验的副本。P5 本体中开车创怪没有收益，P5R 中有了收益后刷刷刷的体验得到了大幅改善（兄弟们一定要把龙司 coop 升到 7 啊）</p><h3 id="日常社交"><a href="#日常社交" class="headerlink" title="日常社交"></a>日常社交</h3><p>P5R 的日常系统并未在战斗系统的优秀下黯然失色，而是独立于战斗的同时又与其相辅相成，达成了优秀的联动。虽然主角团在异世界中战斗，但主角们也是生活在日常中的人，日常的行动依然会影响战斗的发挥。锻炼身体可以增加体力上限，冥想打坐可以增加魔力上限，与同伴一起玩飞镖可以增加换手默契，和演讲家打好关系可以敲诈敌方更多钱和道具，这样的例子比比皆是</p><h2 id="剧情"><a href="#剧情" class="headerlink" title="剧情"></a>剧情</h2><h3 id="叙述主题"><a href="#叙述主题" class="headerlink" title="叙述主题"></a>叙述主题</h3><p>在 P5R 的主线剧情中，主角团穿梭于一座座由扭曲欲望幻化而成的殿堂中，与象征着七大罪的幻影 boss 战斗，最后偷走作为欲望源泉的秘宝。这其中令我印象深刻的不仅仅是殿堂对扭曲欲望的展现，也在于殿堂这等扭曲存在竟仍如此井然有序。奥村的宇宙工厂有着以员工作为无情感机器人的夸张讽刺，却也以等级森严、制度明确的规则为底色；狮童以议事堂作为沉溺国家上的方舟的幻想傲慢自大，这艘游轮却也离不开他现实中旧华族、黑社会等势力的支持。在 P5R 中，“欲望”一词并不仅是简单的“饿了要吃，困了要睡”这样纯粹出自个人内心的动物性欲望，更是庞大的、盘根错节的社会性欲望。这种欲望最大的特点就是现代性，它生发于一个系统、一个群体之中。它非人化的力量并不仅仅作用于被剥削者，也作用在剥削者的身上。无论是加害者还是被害者，都充其量不过是系统中的一个组件，一个可以随时替换的齿轮。欲望并不由个人，而从现代的铁笼生产出，又被系统本身内部实现与消费，形成可悲的循环。于是我们看到，一列列动车驶进印象空间的最深处，乘客自发的走向囚笼，享受着不必选择的自由，顶礼膜拜圣杯的诞生。“To be or not to be，这个问题的答案不再是生存或毁灭、顺从或反抗，而是漠不关心。”自称亚尔达拜特的伪神自此萌生，吸食着人类的生命力</p><h3 id="主线剧情"><a href="#主线剧情" class="headerlink" title="主线剧情"></a>主线剧情</h3><p>P5R 大体的主线剧情采用了倒叙的手法，以主角被捕为开局，用在狱中的审讯引出一年以来的生活。每当主角经历了一个大事件，镜头都会从回忆中切出来到审讯室，反复提醒玩家最终被捕的结局。但结局本身的不完整与隐晦又给予了玩家足够的想象空间，持续地吊着玩家的胃口。随着故事的推进，随着事件全貌的逐渐展开，在时间线终于接上开头被捕的片段时，玩家终于有足够的了解与充足的信息，去完成一个戏耍命运的绝妙诡计。这无疑是一个倒叙的优秀范本</p><h3 id="支线剧情"><a href="#支线剧情" class="headerlink" title="支线剧情"></a>支线剧情</h3><p>除了主线故事之外，P5R 的支线设计也足以令人称道。从并肩作战的怪盗团队友到街边巷里的各路人士，P5R 的重要配角都对应一张大阿尔卡纳牌。配角数量众多，但每个角色的人设和故事都有其对应探讨的主题。身为画家的喜多川执着地寻求着美，参选议员的吉田在政治党争的漩涡中坚守自己的正义，记者大宅不顾上层的压力去寻找同伴失踪的真相，模型枪店长岩井拼尽全力不让身为黑道的过去追上自己无辜的养子。他们都或多或少都因主角的帮助而得到了成长，而他们也在最后主角陷入困境时动用自己的关系竭尽全力地帮助主角</p><h3 id="日常琐碎"><a href="#日常琐碎" class="headerlink" title="日常琐碎"></a>日常琐碎</h3><p>P5R 的日常细节也做得相当优秀。因为是箱庭而非开放世界，场景内的可互动元素非常丰富。每天的电视新闻，上课的抽查答题，街边路人的谈话内容，路边店铺上架的商品，这些都会随着时间的流逝而变化，仿佛这真的是一个活生生的世界一般</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>抓眼的美术、爽快的战斗、优秀的剧情、沉浸的日常，P5R 最为人称道的就是其代入感。130 多现实小时、300 多游戏天，让人仿佛感觉真的于其中度过了另一段人生。当最后的时刻来临，看着仍旧熙攘的街道，于其中生活的过往将不舍之情引燃，化为（看完优秀作品经常会有的）萦绕在心头的怅然之感。P5R 无愧于其“天下第一”的名号</p>]]></content>
    
    
    <summary type="html">P5R 天下第一！</summary>
    
    
    
    
    <category term="游戏" scheme="https://imagebuilder1837.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="女神异闻录" scheme="https://imagebuilder1837.github.io/tags/%E5%A5%B3%E7%A5%9E%E5%BC%82%E9%97%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人博客（下）</title>
    <link href="https://imagebuilder1837.github.io/2023/12/04/2023-12-04-1/"/>
    <id>https://imagebuilder1837.github.io/2023/12/04/2023-12-04-1/</id>
    <published>2023-12-04T13:53:40.000Z</published>
    <updated>2025-09-21T02:37:57.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搭建个人博客（下）"><a href="#搭建个人博客（下）" class="headerlink" title="搭建个人博客（下）"></a>搭建个人博客（下）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇博客主要分享了我一路把 Hexo 博客搭到能用的流程，看着就像一篇正经介绍的教程。这其实是因为截至上篇结尾我都是顺风顺水地跟着大佬们的文章走的。但这回就得好好介绍介绍我被 <a href="https://github.com/esappear/hexo-theme-clover">clover</a> 狠狠拷打的故事了</p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>不介意的话 Hexo 默认的 landscape 也不是不行，但我在翻阅<a href="https://juejin.cn/post/7053744641383874574">一篇掘金的主题推荐</a>时被 clover 狠狠地吸引了</p><p>好，既然选定了主题，那就赶紧整起来！</p><p>跟着 clover 主题的 <code>README.md</code> 一步步走：</p><pre><code class="shell">git clone https://github.com/esappear/hexo-theme-clover themes/clovernpm install hexo-renderer-sass --save</code></pre><p>改一下根目录的 <code>_config.yml</code>：</p><pre><code class="yaml">theme: cloverhighlight:  enable: false</code></pre><p>把几个主界面的文件创建好：</p><pre><code class="shell">hexo new page &quot;tags&quot;</code></pre><pre><code class="yaml">---layout: tagtitle: tags---</code></pre><pre><code class="shell">hexo new page &quot;categories&quot;</code></pre><pre><code class="yaml">---layout: categorytitle: categories---</code></pre><pre><code class="shell">hexo new page &quot;about&quot;</code></pre><pre><code class="yaml">---layout: abouttitle: about---</code></pre><p>Generate!</p><pre><code class="shell">ERROR ReferenceError: _ is not defined</code></pre><p>啊？</p><h2 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h2><p>我看着报错信息，大脑宕机了一瞬间。不过既然出问题了，那就去 GitHub 上翻翻 issue。一看，<a href="https://github.com/esappear/hexo-theme-clover/issues/22">最新的 issue</a> 提到的就是这个问题：</p><p><img src="/images/2023-12-04-1-01.jpeg" alt="2023-12-04-1-01.jpeg"></p><p>好家伙，都是三年前的 issue 了，看看解决了没：</p><p><img src="/images/2023-12-04-1-02.jpeg" alt="2023-12-04-1-02.jpeg"></p><p>行吧，看来只能自己动手丰衣足食了</p><h2 id="修bug"><a href="#修bug" class="headerlink" title="修bug"></a>修bug</h2><p>叠个甲，我此前几乎完全没有 Javascript 基础，所有相关知识都是现学现卖，解决方法可能又莽又蠢，大佬们轻点喷😫</p><h3 id="一把梭"><a href="#一把梭" class="headerlink" title="一把梭"></a>一把梭</h3><p>再看一眼报错信息：</p><pre><code class="shell">ERROR ReferenceError: _ is not defined</code></pre><p>这个报错在 <code>layout</code> 文件夹下的 <code>archive.ejs</code>、<code>category.ejs</code>、<code>tag.ejs</code>，以及 <code>layout/_partial</code> 里的 <code>footer.ejs</code>、<code>nav.ejs</code> 都有发生。看起来是一个变量未定义的问题，先去找找这个下划线是何方神圣。一路找到 <code>scripts/home.js</code> 里：</p><pre><code class="javascript">&#39;use strict&#39;;var pagination = require(&#39;hexo-pagination&#39;);var assign = require(&#39;object-assign&#39;);var _ = require(&#39;lodash&#39;);</code></pre><p>看起来这个下划线本来应该是一个叫 lodash 的导入的库，但不知道为什么这些 ejs 模板没办法使用这个变量，我本着最简单直接的想法（未定义就再给它定义上）在所有报错的文件开头都加了一句：</p><pre><code class="javascript">var _ = require(&#39;lodash&#39;);</code></pre><p>再跑一遍试试：</p><pre><code class="shell">ERROR ReferenceError: require is not defined</code></pre><p>看来是我想得太简单了</p><h3 id="一点-Javascript-历史"><a href="#一点-Javascript-历史" class="headerlink" title="一点 Javascript 历史"></a>一点 Javascript 历史</h3><p>话说 require 是 Javascript 中的导入函数，直觉上这类函数应该是语言本身的内置函数，怎么会未定义呢？我去网上翻了翻，发现这似乎与 Javascript 作为浏览器脚本语言的定位有关</p><p>根据<a href="https://www.cnblogs.com/libin-1/p/7127481.html">这篇博客园的文章</a>，Javascript 并不是一种模块化编程语言，在 es6 之前它是不支持类（class）的，自然也没有模块一说。2009年，美国程序员 Ryan Dahl 创立了 Nodejs 项目，将 Javascript 语言用于服务器端编程。前端的复杂程度有限，没有模块也是可以的，但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。Nodejs 使用了 CommonJS 规范来实现模块化编程，require 就是其中加载模块的全局性方法</p><p>但 Hexo 不就是基于 Nodejs 环境的吗，怎么会用不了 require 呢？</p><p>我又找到了<a href="https://blog.csdn.net/qq_38977714/article/details/117252524">一篇文章</a>，似乎是因为在 Nodejs 大版本 14 以上，require 作为 CommonJS 的一个命令已经不支持直接使用了。文章也给出了解决方法：</p><pre><code class="javascript">import &#123; createRequire &#125; from &#39;module&#39;;const require = createRequire(import.meta.url);</code></pre><p>试试：</p><pre><code class="shell">ERROR SyntaxError: Cannot use import statement outside a module while compiling ejs</code></pre><p>这回网上的解决方法有两种：</p><ol><li>使用 <code>.mjs </code> 后缀名。</li><li>在 <code>package.json</code> 中加入 <code>&quot;type&quot;: &quot;module&quot;</code>。</li></ol><p>发生问题的是 ejs 模板文件，第一种方法肯定不能采用了；第二种方法经尝试仍然会报错</p><p>那把 Nodejs 降级到 14 以下的版本呢？</p><p>我下载了 12.22.12 版本的 Nodejs 进行覆盖安装。需要注意的是，用户目录 <code>AppData</code> 下 <code>Local</code> 和 <code>Roaming</code> 中的缓存文件夹 <code>npm</code>、<code>npm-cache</code> 以及 <code>node-gyp</code> 需要手动删除以防版本冲突。</p><p>结果还是失败了，无论是 require 还是 import 都会报错</p><p>这下思路断了</p><h3 id="no-lodash"><a href="#no-lodash" class="headerlink" title="no-lodash"></a>no-lodash</h3><p>我开始失意地翻阅 <a href="https://hexo.io/zh-cn/docs/">Hexo 官方文档</a>，在“变量”一节找到了这样一句话：</p><blockquote><p>从 Hexo 5.0.0 开始，Lodash 已从全局变量中移除。迁移时 <a href="https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore">You-Dont-Need-Lodash-Underscore</a> 或许能为你提供帮助</p></blockquote><p>简而言之就是：既然用不了 lodash，那就把所有 lodash 的函数全换掉</p><p>不错！有够简单粗暴的！</p><p>接下来就是找出所有下划线并一个个换成等效函数的体力活了。不过这个项目中提供的都是只适用于数组的方法，object 相关的替换我是自己用 for 循环写的。于是 lodash 被我彻底踢出了这个主题</p><h3 id="一个小插曲"><a href="#一个小插曲" class="headerlink" title="一个小插曲"></a>一个小插曲</h3><p>Generate!</p><pre><code class="shell">Error: Unknown output style &quot;nested&quot;</code></pre><p>找到主题文件夹下的 <code>_config.yml</code>，把 <code>node_sass</code> 下的 <code>outputStyle</code> 属性删掉就行了</p><p>至此，bug fix 的环节算是告一段落了，我也把修改的部分提交了<a href="https://github.com/esappear/hexo-theme-clover/pull/24">一个 PR</a> ，希望能被 merge 吧</p><h2 id="微调"><a href="#微调" class="headerlink" title="微调"></a>微调</h2><p>clover 是 <a href="https://esappear.github.io/clover/">Clover Tuan</a> 太太编写的，但是并没有注明使用的开源许可证，所以如果太太您在看并且觉得这样不合适的话还请告知</p><h3 id="首页图标"><a href="#首页图标" class="headerlink" title="首页图标"></a>首页图标</h3><p>太太在首页展示的默认图标有 Dribbble、Behance、Lofter、Instagram 以及 GitHub。那如果我想加点别的图标该怎么办？不如说这个首页图标究竟是怎么回事？</p><p>既然搞不懂，就去看看这究竟是怎么实现的。我直接简单粗暴地拿元素选择器框中了 GitHub 图标：</p><p><img src="/images/2023-12-04-1-03.jpeg" alt="2023-12-04-1-03.jpeg"></p><p>居然不是图片？逐一查看和它相关的 css，发现玄机藏在 <code>source/css/font.scss</code> 中：</p><pre><code class="scss">@font-face &#123;  font-family: &#39;iconfont&#39;;  /* project id 861369 */  src: url(&#39;//at.alicdn.com/t/font_861369_9voy0xmnmvl.eot&#39;);  src: url(&#39;//at.alicdn.com/t/font_861369_9voy0xmnmvl.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),  url(&#39;//at.alicdn.com/t/font_861369_9voy0xmnmvl.woff&#39;) format(&#39;woff&#39;),  url(&#39;//at.alicdn.com/t/font_861369_9voy0xmnmvl.ttf&#39;) format(&#39;truetype&#39;),  url(&#39;//at.alicdn.com/t/font_861369_9voy0xmnmvl.svg#iconfont&#39;) format(&#39;svg&#39;);&#125;.iconfont&#123;  font-family:&quot;iconfont&quot; !important;  font-size:16px;font-style:normal;  -webkit-font-smoothing: antialiased;  -webkit-text-stroke-width: 0.2px;  -moz-osx-font-smoothing: grayscale;  &amp;.icon-behance::before &#123;    content: &#39;\e919&#39;;  &#125;  &amp;.icon-lofter::before &#123;    content: &#39;\e63c&#39;;  &#125;  &amp;.icon-instagram::before &#123;    content: &#39;\e626&#39;;  &#125;  &amp;.icon-dribbble::before &#123;    content: &#39;\e6c3&#39;;  &#125;  &amp;.icon-github::before &#123;    content: &#39;\e799&#39;;  &#125;  &amp;.icon-arrow-left::before &#123;    content: &#39;\e91a&#39;;  &#125;  &amp;.icon-arrow-right::before &#123;    content: &#39;\e636&#39;;  &#125;&#125;</code></pre><p>经过一番搜索，我大致明白了原理：通过引用字体图标文件，让特定 Unicode 字符显示为图标的样子</p><p>明白了原理就可以开始动手了。找图标可以用阿里的在线字体图标服务 <a href="https://www.iconfont.cn/">iconfont 矢量图标库</a>，只要不商用一般也不会牵扯到版权问题</p><p>先注册一个账号，然后可以搜索自己需要的图标（因为太太的代码原因，请选择名称全小写的图标），添加入库：</p><p><img src="/images/2023-12-04-1-04.jpeg" alt="2023-12-04-1-04.jpeg"></p><p>挑选完图标之后，点击网站右上角带红点的购物车，选择添加至项目（没有项目可以新建一个）：</p><p><img src="/images/2023-12-04-1-05.jpeg" alt="2023-12-04-1-05.jpeg"></p><p>此时会自动跳转到项目里面，点击“查看在线链接”并生成代码：</p><p><img src="/images/2023-12-04-1-06.jpeg" alt="2023-12-04-1-06.jpeg"></p><p>记下每一个图标的 Unicode 编号，可以点击“编辑”查看：</p><p><img src="/images/2023-12-04-1-07.jpeg" alt="2023-12-04-1-07.jpeg"></p><p><img src="/images/2023-12-04-1-08.jpeg" alt="2023-12-04-1-08.jpeg"></p><p>用生成的代码替换掉原来 <code>source/css/font.scss</code> 中的部分，每个图标也照葫芦画瓢地写如下一段：</p><pre><code class="scss">  &amp;.icon-ICONNAME::before &#123;    content: &#39;\ICONUNICODE&#39;;  &#125;</code></pre><p>我的替换如下：</p><pre><code class="scss">@font-face &#123;  font-family: &#39;iconfont&#39;;  /* Project id 4356364 */  src: url(&#39;//at.alicdn.com/t/c/font_4356364_82dhsvzbmln.woff2?t=1701695612820&#39;) format(&#39;woff2&#39;),       url(&#39;//at.alicdn.com/t/c/font_4356364_82dhsvzbmln.woff?t=1701695612820&#39;) format(&#39;woff&#39;),       url(&#39;//at.alicdn.com/t/c/font_4356364_82dhsvzbmln.ttf?t=1701695612820&#39;) format(&#39;truetype&#39;);&#125;.iconfont&#123;  font-family:&quot;iconfont&quot; !important;  font-size:16px;font-style:normal;  -webkit-font-smoothing: antialiased;  -webkit-text-stroke-width: 0.2px;  -moz-osx-font-smoothing: grayscale;  &amp;.icon-bilibili::before &#123;    content: &#39;\e600&#39;;  &#125;  &amp;.icon-github::before &#123;    content: &#39;\e799&#39;;  &#125;  &amp;.icon-rss::before &#123;    content: &#39;\e6d0&#39;;  &#125;  &amp;.icon-arrow-left::before &#123;    content: &#39;\e75b&#39;;  &#125;  &amp;.icon-arrow-right::before &#123;    content: &#39;\e75c&#39;;  &#125;&#125;</code></pre><p>来到主题文件夹下的 <code>_config.yml</code>，修改 social 部分的属性值：</p><pre><code class="yaml">social:  bilibili: https://space.bilibili.com/366719977  GitHub: https://github.com/image-builder-1837  RSS: /atom.xml</code></pre><p>看看效果：</p><p><img src="/images/2023-12-04-1-09.jpeg" alt="2023-12-04-1-09.jpeg"></p><p>Done!</p><h3 id="RSS"><a href="#RSS" class="headerlink" title="RSS"></a>RSS</h3><p>个人博客怎么能不支持 RSS 呢？好在 Hexo 配置 RSS 也不复杂，首先下载生成 RSS 的插件：</p><pre><code class="shell">npm install hexo-generator-feed --save</code></pre><p>在根目录下的 <code>_config.yml</code> 配置：</p><pre><code class="yaml"># Extensionsplugins:  hexo-generator-feed#Feed Atomfeed:  type: atom  path: atom.xml  limit: 20</code></pre><p>在主题文件夹下的 <code>_config.yml</code> 配置：</p><pre><code class="yaml"># RSSrss: /atom.xml</code></pre><p>这样就会在网站的 <code>/atom.xml</code> 下生成 RSS 订阅了（不知道为什么这里是乱码，我尝试在阅读器里打开是正常的）：</p><p><img src="/images/2023-12-04-1-10.jpeg" alt="2023-12-04-1-10.jpeg"></p><p>可以在首页也加一个 RSS 的图标，具体的写法可以往上翻翻</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>剩下的都是些微不足道的小改动，比如增加 mail 发送链接啦，增加 copyright 跳转链接什么的</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>嗷嗷嗷终于写完了！单论个人博客的搭建其实并没有很复杂，主要是我选主题的问题（</p><p>咳咳，虽然搞七搞八地配置一大通确实挺麻烦，但完成的时候简直成就感爆棚！而且这几天搭博客也学到了一些奇奇怪怪的知识，比如在 GitHub merge PR 的时候要记得 squash and merge 而不是直接 merge（会让 commit history 变丑的！），又或者是一段关于 Javascript 模块化编程的历史等等。试想刚开始搭博客时怎么想到能扯到这些方面？也算是意料外的收获吧</p>]]></content>
    
    
    <summary type="html">clover 主题那些事儿</summary>
    
    
    
    
    <category term="编程" scheme="https://imagebuilder1837.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Hexo" scheme="https://imagebuilder1837.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人博客（上）</title>
    <link href="https://imagebuilder1837.github.io/2023/12/03/2023-12-03-1/"/>
    <id>https://imagebuilder1837.github.io/2023/12/03/2023-12-03-1/</id>
    <published>2023-12-03T08:53:29.000Z</published>
    <updated>2025-09-21T02:37:57.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搭建个人博客（上）"><a href="#搭建个人博客（上）" class="headerlink" title="搭建个人博客（上）"></a>搭建个人博客（上）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>“要搭个人博客！”这个想法我也不太清楚具体是什么时候出现的，大概是看了诸多大佬的博客之后就自然而然地想要效仿吧。总之，借着一个奇怪的契机（K 佬：去搭一个博客 我：好嘞），也是正式开始整博客了。作为第一篇博客，就讲讲我搭博客的过程以及遇到的一些小麻烦吧</p><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>在怎么搭个人博客这个问题上，我考虑过三种整法：</p><ol><li>在现有的博客平台（如 CSDN、博客园等）上写</li><li>用博客框架写，部署在 GitHub Pages 上</li><li>用博客框架写，部署在云服务器上</li></ol><p>考虑了一下，如果要搭个人博客，我更喜欢自己能够定制整个页面，况且本人对 CSDN 等的好感度一直都挺低的，于是方案一被直接抛弃了；方案三需要我掏钱买一台暂时还没有别的用处的仅仅用来搭博客的云服务器以及一个域名，虽然有一台自己的服务器和一个自己的域名实在是酷毙了，但我的钱包还是让我放弃了方案三。最终我选择了折中的方案二，也就是广受欢迎的 Hexo + GitHub Pages 建站</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>博客，启动！</p><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>安装 Hexo 需要 Nodejs 环境，先去 <a href="https://nodejs.org/">Nodejs 官网</a>下载安装包。一般来说会有 LTS 和 Current 两个版本，LTS 全称是 Long Term Support，也就是长期支持版本，相对会更稳定且不容易出 bug，所以正常情况下载 LTS 版本就行了。安装过程就是一路无脑 Next，安装完后可以在 cmd 中运行以下两个命令验证是否安装成功：</p><pre><code class="shell">node -vnpm -v# 如果都输出版本号就是安装成功了</code></pre><p>接下来安装 Hexo：</p><pre><code class="shell">npm install -g hexo-cli  # -g 指全局安装，局部安装可以运行 npm install hexo</code></pre><p>验证安装成功：</p><pre><code class="shell">hexo v  # 输出 Hexo 以及依赖包的版本</code></pre><p>准备一个用来存放博客文件的空文件夹，在这个文件夹中打开 cmd 并运行：</p><pre><code class="shell">hexo init  # 博客目录的初始化npm install  # 安装博客需要的包</code></pre><p>这个时候文件夹中应该多出了一大堆乱七八糟的文件和文件夹。太棒了，已经初始化好了！来看看 Hexo 送我们的新手大礼包是什么样的吧：</p><pre><code class="shell">hexo g  # 从你写的博客中生成静态网页文件，以后每次更新完博客都要运行一遍hexo s  # 在本地 localhost:4000 生成预览</code></pre><p>在浏览器中访问 <code>localhost:4000</code>：</p><p><img src="/images/2023-12-03-1-00.jpeg" alt="2023-12-03-1-00.jpeg"></p><p>Hello Hexo!</p><h3 id="Git-GitHub"><a href="#Git-GitHub" class="headerlink" title="Git &amp; GitHub"></a>Git &amp; GitHub</h3><p>我在搭博客之前就已经在使用这个游戏存档工具和最佳菜谱网站了，如果没安装 Git 或者没有 GitHub 账号的话可以参考网上各位大佬们的教程（我真懒）</p><p>装完 Git 以及注册完 GitHub 账号之后，需要新建一个仓库（repository），并取名叫 <code>USERNAME.github.io</code>（USERNAME就是你在 GitHub 的账号名）这个名字具有特殊意义，GitHub 会把这个仓库里的文件作为网站文件建站，可以通过 <code>https://USERNAME.github.io</code> 访问</p><p>值得一提的是，许多教程中提到需要配置 GitHub SSH key，但那其实是通过 SSH 连接 GitHub 才必要的步骤，如果在等会讲到的 Hexo 配置文件中使用 HTTPS 连接就可以省去这个步骤。我嘛，因为 <a href="https://github.com/BeyondDimension/SteamTools/releases/tag/3.0.0-rc.2">Watt Toolkit 3.0.0-rc.2</a> 在代理 GitHub 时并没有处理 22 端口，不停止加速就无法使用 SSH 连接，于是我毫不犹豫地选择了 HTTPS 连接</p><h3 id="Hexo-Git-GitHub"><a href="#Hexo-Git-GitHub" class="headerlink" title="Hexo + Git + GitHub"></a>Hexo + Git + GitHub</h3><p>在博客的文件夹下有个叫做 <code>_config.yml</code> 的文件，是整个博客的配置文件。不过现在需要它做的暂时只是让它告诉 Hexo 用什么方式（Git）把博客放到哪里（Github）去。随便用什么文字编辑器打开它，保证当中有这么几行：</p><pre><code class="yaml">deploy:  type: git  repo: https://github.com/USERNAME/USERNAME.github.io.git  branch: main</code></pre><p>当然也可以选择用 SSH 而不是 HTTPS 的方式连接 Github，需要把 repo 属性改成 <code>git@github.com:USERNAME/USERNAME.github.io.git</code> 以及配置 Github SSH key，详情请见网上各大佬的文章（懒开二度）</p><p>接下来装能让 Hexo 通过 Git 部署博客的插件：</p><pre><code class="shell">npm install hexo-deployer-git --save</code></pre><p>部署！</p><pre><code class="shell">hexo d</code></pre><p>去 <code>https://USERNAME.github.io</code> 看看：</p><p><img src="/images/2023-12-03-1-01.jpeg" alt="2023-12-03-1-01.jpeg"></p><p>Hello GitHub Hexo!</p><h2 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h2><p>第一步的搭建已经完成了，该回头看看究竟发生什么了。首先要看的就是根目录下的 <code>_config.yml</code> 这个配置文件</p><p><code>.yml</code> 扩展名的文件使用的是 YAML 语言，因其能清晰地表达层次结构，常用于书写配置文件。YAML 的语法并不复杂，只需要 10 分钟左右就足以掌握其大致用法</p><p>了解大致用法之后，就可以正式看看 <code>_config.yml</code> 里面都塞了些什么了。完整的配置选项可以在 <a href="https://hexo.io/zh-cn/docs/configuration">Hexo 官方文档</a>的“配置”一节中查看，下面是一些我用到的配置选项：</p><pre><code class="yaml">title: Image Builder  # 网站标题，就是显示在标签页上的文字subtitle: iamge_builder&#39;s blog  # 副标题description: iamge_builder&#39;s blog  # 简介，主要是给搜索引擎看的keywords: 编程 网站  # 关键词author: iamge_builder  # 作者名字language: default  # 网站语言，这个需要根据主题灵活调整timezone: Asia/Shanghai  # 时区，中国大陆填 Asia/Shanghai 就行url: https://image-builder-1837.github.io  # 网站网址theme: clover  # 网站主题</code></pre><h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><h3 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h3><p>Hexo 创建的博客文件默认使用 Markdown 语法书写，这年头不会 Markdown 真的还算编程人吗（暴论）</p><p>调侃归调侃，Markdown 最大的特点就是将样式融合进了文本之中，这使得书写 Markdown 时并非像 Word 那样需要用鼠标一个个选中调整，而是双手不离开键盘就能同时完成书写和排版。如今无论是 GitHub 的 <code>README.md</code> 或是大部分笔记软件如 Obsidian、Typora、trilium 等都使用 Markdown 语法，这值得每个希望能集中精神码字的人学习</p><h3 id="子文件夹"><a href="#子文件夹" class="headerlink" title="子文件夹"></a>子文件夹</h3><p>在正式开始写博客之前，大致了解一下博客文件夹中几个子文件夹的作用有助于理解 Hexo 的工作方式</p><ul><li>node_modules：存放 Nodejs 的一些包</li><li>public：<code>hexo g</code> 生成的静态网页文件都放在这里，<code>hexo d</code> 也是把这个文件夹发送给 GitHub</li><li>scaffolds：等会的博客文件都是用这里面的模板生成的</li><li>source：博客、主页、归档、关于等页面文件存放的位置</li><li>themes：放主题的地方</li></ul><h3 id="New"><a href="#New" class="headerlink" title="New!"></a>New!</h3><p>来生成一篇新博客！</p><pre><code class="shell">hexo new &quot;Title&quot;</code></pre><p>Hexo 有默认有三种模板：</p><ul><li>post：默认模板，用于生成博客</li><li>page：用来生成一些诸如主页、归档、关于等非博客页面文件</li><li>draft：草稿，感觉没啥用</li></ul><p>默认使用 post 模板，这个例子中会用 <code>scaffolds/post.md</code> 在 <code>source/_posts </code> 下生成 <code>Title.md</code>。如果你要生成“关于”页面：</p><pre><code class="shell">hexo new page &quot;About&quot;</code></pre><p>就会用 <code>scaffolds/page.md</code> 在 <code>source/About</code> 下生成 <code>index.md</code></p><p>接下来就可以用你喜欢的 Markdown 编辑器<del>（比如 VSCode）</del>打开 <code>Title.md</code> 进行写作了。写完依旧是 <code>hexo g</code> 加 <code>hexo s</code> 预览，<code>hexo d</code> 部署，就不在此赘述了</p><h3 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h3><p>有时在博客中需要引用图片，一种简单直接的做法就是把图片放在 <code>source</code> 文件夹下通过相对路径引用。但这种做法在图片数量越来越多的情况下会狠狠地拖慢网站的加载速度。所以可以选择把图片上传到图床里并使用 Markdown 图片语法 <code>![ImageName](ImageLink)</code> 来引用。所谓的图床就是见网上大佬的科普（三回啊三回）</p><p>其实也可以专门建一个 GitHub 仓库充当图床，我就是这么干的</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>至此，Hexo 的搭建以及基本使用都已经讲完了，下回该讲讲让我博客拖了整整三天才完成的罪魁祸首——主题了🥶</p>]]></content>
    
    
    <summary type="html">使用 Hexo + GitHub Pages 搭建个人博客</summary>
    
    
    
    
    <category term="编程" scheme="https://imagebuilder1837.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Hexo" scheme="https://imagebuilder1837.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
